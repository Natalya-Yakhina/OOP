ДЗ 6. ООП Дизайн и Solid

- Взять реализованный код в рамках семинара 4 и продемонстрировать 
применение принципов, усвоенных на семинаре.
- Нужно в проекте прокомментировать участки кода, которые рефакторим, какой принцип применяем и почему.
------------------------------------------------------------------
## ПРИНЦИПЫ ООП: 

### 1. **Single responsibility principle - Принцип единственной ответственности**

***Принцип гласит, что может быть только одна причина, приводящая к изменению класса. 
Каждый класс выполняет только одну задачу  и не имеет зависимостей на другие классы.***

### 2. **Open-closed principle - Принцип открытости/закрытости**

***Классы должны быть открыты для расширения и одновременно закрыты для модификации.
Должна быть возможность добавлять новые свойства и расширять класс без изменения 
внутренней реализации существующих свойств. Реализовывать дополнительные методы необходимо 
в наследуемом классе, чтобы не сломать родительский класс.***
 - «Закрыт для модификации»
 - «Открыт для расширений»

### 3. **Liskov substitution principle - Принцип подстановки Лисков**

***Требует возможности использования любых порожденных классов на месте родительских.
При этом они должны обладать тем же поведением, что и родительские классы, без внесения изменений.
Этот принцип гарантирует, что порожденный класс не изменяет определение типа
родительского и его поведение. Объекты в программе можно заменить их наследниками без изменения свойств программы.***

### 4. **Interface segregation principle - Принцип разделения интерфейса**

***Клиенты не должны реализовывать интерфейсы, которые они не используют.
Данный принцип требует разделения «толстых» интерфейсов на несколько специализированных, связанных общей функциональностью. 
Лучше добавить много специализированных интерфейсов, чем один.***

### 5. **Dependency inversion principle - Принцип инверсии зависимостей**

***Принцип инверсии зависимостей***
- модули высокого уровня не должны зависеть от модулей нижнего уровня. 
- И те, и другие должны зависеть от абстракций.
- абстракции не должны зависеть от деталей.
  Детали должны зависеть от абстракций.

-----------------------------------------------------------------------------
### ДЗ 6. ООП Дизайн и Solid:

В рамках 4 семинара было создано 4 класса (User, Dog, UserComparator, UserIterator) 
В домашней работе к 4 семинару были созданны классы (Teacher, TeacherComparator, TeacherGroup, TeacherIterator)

[//]: # (На семинаре разобрано создание 5 классов &#40;User, Student, StudentIterator, StudentComparator, StudentGroup&#41;, ни один из классов не являлся абстрактным.)

[//]: # ()
[//]: # (В домашней работе к семинару добавлены классы teacher.Teacher, teacher.TeacherComparator, teacher.TeacherGroup, teacher.TeacherGroupIterator >)

При работе над проектом к ДЗ_6 выполнена следующая реструктурзация проекта: 
1. Созданы абстрактные классы UserBase & UserBaseGroup.
2. Добавлен интерфейс UserInterface, добавлены поля в класс User.
3. Изменена структура проекта - классы распределены по директориям для лучшего восприятия информации.


Реализация принципов SOLID в проекте:
Принцип единственной ответственности (Single Responsibility Principle) реализован в классах 
Student & Teacher, наследуемые от класса User, но имеют одно поле (Student - studentCourse) 
(Teacher - teacherId), которое определено в каждом из классов для определенной категории. 
А также в классах StudentGroup & TeacherGroup, которые наследуются от UserGroup.
Принцип подстановки лисков можно проверить путем замены объектов наследниками (User заменить на Teacher или Student) и программа продолжит работать без изменения свойств.
Принцип разделения интерфейсов реализован путем создания UserInterface.
Т.к. в конкретном проекте стояла задача сравнить объекты между собой, добавлен только один интерфейс. В случае, если бы потребовалось дополнить программу другим функционалом, то можно было бы создать еще несколько интрефейсов.

Принцип открытости/зактрытости реализован в домашней работе путем создания getter & setter, и обращение к полям класса через эти методы, что позволяет соблюсти принцип закрытости сущностей для модификации, а создание классов-наследников (таких как Student & Teacher), позволяет соблюсти принцип открытости - то есть наши сущности открыты для дальнейших расширений.
Принцип инверсии зависимостей реализован следующим образом: в данном проекте абстрактные классы BaseUser & BaseUserGroup не зависят от деталей. В абстрактных классах перечислены поля, которые будут использоваться в проекте, а детали реализованы в классах-наследниках. Модули верхних уровней не зависят от модулей нижних уровней.